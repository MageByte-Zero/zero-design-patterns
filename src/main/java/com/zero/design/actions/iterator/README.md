# 迭代器模式
## 定义
迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。
迭代器模式让我们能游走于聚合内的每一个元素，而又不暴露内部的表示。把游走的任务放在迭代器上，而不是聚合上，这样简化了聚合
的接口和实现，也让责任各得其所。

## 认识迭代器模式
这很有意义：这个模式给你提供了一种方法，可以顺序访问一个聚集对象中的元素，而又不用知道内部是如何表示的。
。在设计中使用迭代器的影响是明显的：如果你有一个统一的方法访问聚合中的每一个对象，你就可以编写多态的代码
和这些聚合搭配使用，如同前面的printMenu()方法一样，只要有了迭代器这个方法，根本不管菜单项究竟是由数组还
是由ArrayList（或者其他能创建迭代器的东西）来保存的。
另一个对你的设计造成重要影响的，是迭代器模式把这些元素之间游走的责任交给迭代器，而不是聚合对象。这不仅让
聚合的接口和实现变得更简洁，也可以让聚合更专注在它所应该专注的事情上面（也就是管理对象组合），而不必去理
会遍历的事情。

## 意义
单一责任

如果我们允许我们的聚合实现它们内部的集合，以及相关的操作和遍历的方法，又会如何？我们已经知道这会增加聚合中的方法个数，
但又怎样呢？为什么这么做不好？
想知道为什么，首先你需要认清楚，当我们允许一个类不但要完成自己的事情（管理某种聚合），还同时要担负更多的责任（例如遍历）
时，我们就给了这个类两个变化的原因。两个？没错，就是两个！如果这个集合改变的话，这个类也必须改变，如果我们遍历的方式改变
的话，这个类也必须跟着改变。所以，再一次地，我们的老朋友“改变”又成了我们设计原则的中心：

设计原则：一个类应该只有一个引起变化的原因

我们知道要避免类内的改变，因为修改代码很容易造成许多潜在的错误。如果有一个类具有两个改变的原因，那么这会使得将来该类的
变化几率上升，而当它真的改变时，你的设计中同时有两个方面将会受到影响。
没错，这听起来很容易，但其实做起来并不简单：区分设计中的责任，是最困难的事情之一。我们的大脑很习惯看着一大群的行为，然后
将它们集中在一起，尽管他们可能属于两个或者多个不同的责任。想要成功的唯一方法，就是努力不懈地检查你的设计，随着系统的成长，
随时观察有没有迹象显示某个类改变的原因超出一个。

## 使用场景
爆炸性新闻：对象村餐厅和对象村煎饼屋合并了！
真是个好消息！现在我们可以在同一个地方，享用煎饼屋美味的煎饼早餐，和好吃的餐厅午餐了。但是，好像有一点小麻烦：
新的餐厅想用煎饼屋菜单当作早餐的菜单，使用餐厅的菜单当做午餐的菜单，大家都同意了这样实现菜单项。但是大家无法同意菜单的
实现。煎饼屋使用ArrayList记录他的菜单项，而餐厅使用的是数组。他们两个都不愿意改变他们的实现，毕竟有太多代码依赖于它们了。
### (我们要针对不同的菜单遍历使用不同的遍历方式，使用迭代器模式即可解决)

## 聚集和JAVA聚集
        多个对象聚在一起形成的总体称之为聚集(Aggregate)，聚集对象是能够包容一组对象的容器对象。聚集依赖于聚集结构的抽象化，具有复杂化和多样性。
    数组就是最基本的聚集，也是其他的JAVA聚集对象的设计基础。
    
        JAVA聚集对象是实现了共同的java.util.Collection接口的对象，是JAVA语言对聚集概念的直接支持。从1.2版开始，JAVA语言提供了很多种聚集，
    包括Vector、ArrayList、HashSet、HashMap、Hashtable等，这些都是JAVA聚集的例子。


## 主要角色
　　●　　抽象迭代子(Iterator)角色：此抽象角色定义出遍历元素所需的接口。

　　●　　具体迭代子(ConcreteIterator)角色：此角色实现了Iterator接口，并保持迭代过程中的游标位置。

　　●　　聚集(Aggregate)角色：此抽象角色给出创建迭代子(Iterator)对象的接口。

　　●　　具体聚集(ConcreteAggregate)角色：实现了创建迭代子(Iterator)对象的接口，返回一个合适的具体迭代子实例。

　　●　　客户端(Client)角色：持有对聚集及其迭代子对象的引用，调用迭代子对象的迭代接口，也有可能通过迭代子操作聚集元素的增加和删除。